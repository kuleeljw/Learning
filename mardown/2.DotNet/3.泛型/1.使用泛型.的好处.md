# 使用泛型的好处

### 避免拆装箱、提供编译期类型约束和提高代码运行效率
我们来对比ArrayList和List\<T\>类型来说明这三个好处。前者是 .net frameword2.0之前所使用的非泛型集合，后者是2.0之后使用的泛型集合。
```
ArrayList arrlist = new ArrayList();
//1.添加对象到集合
arrlist.Add(1); 
//2. 获取集合中的第一个对象并赋值给变量
int a = (int)arrlist[0];

List<int> list = new List<int>();
//1.添加对象到集合
list.Add(1);
//2. 获取集合中的第一个对象并赋值给变量
int a = list[0];
```
先看代码//1.的部分，都是调用Add方法向集合里添加对象，乍一看没有什么区别，让我们看看各自的方法定义。
![](http://ouanpg9tc.bkt.clouddn.com/image/learning/generic01/ArrayList01.png)
![](http://ouanpg9tc.bkt.clouddn.com/image/learning/generic01/List01.png)
注意看参数，ArrayList的Add方法接受一个object的参数，而List\<int\>的Add方法接受int类型的参数。显然使用ArrayList在添加对象时会隐式的将对象转换为object类型。

再看代码//2.的部分，我们分别从ArrayList和List\<int\>中取出了第一个对象，显然的由于ArrayList需要保证集合的通用性所以其存储的对象为object类型，所以在取出对象时需要进行类型转换。

看下面一段代码：
![](http://ouanpg9tc.bkt.clouddn.com/image/learning/generic01/list02.png)
泛型集合的例子充分说明了，使用泛型可以避免不必要的装箱和拆箱操作,并且提供编译期的类型检查避免错误的发生。

我们再来对比非泛型集合和泛型集合的执行效率：
```
Stopwatch t1 = new Stopwatch();
Stopwatch t2 = new Stopwatch();

t1.Start();
ArrayList arrlist = new ArrayList();
for (int i = 0; i < 100000000; i++) 
{
    arrlist.Add(i);
}
t1.Stop();

t2.Start();
List<int> list = new List<int>();
for (int i = 0; i < 100000000; i++)
{
    list.Add(i);
}
t2.Stop();

Console.WriteLine($"ArrayList:{t1.Elapsed.TotalMilliseconds}");
Console.WriteLine($"List<int>:{t2.Elapsed.TotalMilliseconds}");
```
![](http://ouanpg9tc.bkt.clouddn.com/image/learning/generic01/list03.png)

我们分别向两个集合中插入1亿个对象，执行的时间差距是巨大的，说明了使用泛型带来的性能提升（如果数据量小差距肯定不会这么巨大，例子只是为了体现效果）。

### 提高代码的重用性




